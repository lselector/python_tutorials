2024-11-02
I have installed Rust and follow the video and main.rs file
from Derek's video

// -------------------------------------------------------------
// Note - there are other good sources:
// https://www.rust-lang.org/learn
// https://doc.rust-lang.org/rust-by-example/ - Online Book
// https://doc.rust-lang.org/book/ - Book 2024
// -------------------------------------------------------------

cargo new rust_tutorial # creates project directory 
                        #   rust_tutorial/Cargo.toml
                        #   rust_tutorial/src/main.rs
# TOML = Tom's Obvious Minimal Language - config file for cargo

cd rust_tutorial
cargo.lock - stores versions of all dependencies
cargo update - updates all dependencies to latest versions
to compile:
    rustc main.rs
or  cargo build
or  cargo run

cargo check - to check that code compiles without errors
cargo build --release

to get rid of "unused" warnings:
#![allow(unused)]
// ---------------- LIBRARIES
use std::io;
use std::io::*;
use rand::Rng;  // add rand crate to Cargo.toml

use std::io::{Write, BufReader, BufRead, ErrorKind};
use std::fs::File;

use std::cmp::Ordering;

mod restaurant;  // want to use restaurant module

// ---------------- FUNCTIONS

fn say_hello(){
    println!("Hello");
}

fn get_sum(x: i32, y: i32){
    println!("{} + {} = {}", x, y, x+y);
}

fn get_sum_2(x: i32, y: i32) -> i32 {
    // Note that no semicolon
    x + y
}

fn get_sum_3(x: i32, y: i32) -> i32 {
    return x + y;
}

// Return multiple values
fn get_2(x: i32) -> (i32, i32){
    return (x+1, x+2);
}

fn print_str(x: String){
    println!("A string {}", x);
}

fn print_return_str(x: String) -> String{
    println!("A string {}", x);
    x
}

fn change_string(name: &mut String){
    name.push_str(" is Happy");
    println!("Message : {}", name);
}

// This function sums values in a list (Receives reference to list)
fn sum_list(list: &[i32]) -> i32 {
    let mut sum = 0;
    for &val in list.iter(){
        sum += &val;
    }
    sum
}

let n2 = vec![4, 5, 6];
sum_list(&n2)


// -------------------------------------------------------------
// You can use interactive environments to learn Rust
// REPL = Read-Eval-Print Loop
// There is an online playground:
//     https://play.rust-lang.org
// or you can install it locally
// cargo install evcxr_repl  # installs  ~/.cargo/bin/evcxr
// then add link "rust to this executable
// cd ~/.cargo/bin
// ln -s evcxr rust
// then type "rust" from prompt - you will get a prompt (like ipython)
// >> let x = 42
// >> println!("The value is: {}", x)
// :quit
// -------------------------------------------------------------
// println!() is a macro. The exclamation mark (!) is telling that it is a macro.
// println!() needs to be a macro because it can handle a variable number 
// of arguments with different types. This flexibility wouldn't be 
// possible with a regular function.
// another macro - format!
    let name = "Alice";
    let age = 30;
    let message = format!("Hello, {}! You are {} years old.", name, age); 
// -------------------------------------------------------------
    let mut name = String::new();      // mutable, empty string
    let greeting = "Nice to meet you"; // immutable
    io::stdin().read_line(&mut name)
        .expect("Didn't Receive Input");
    println!("Hello {}! {}", name.trim_end(), greeting);
// -------------------------------------------------------------

// ----- VARIABLES  ----- 

    const ONE_MIL: u32 = 1_000_000;
    const PI: f32 = 3.141592;

// You can define variables with the same name 
// but with different data types (Shadowing)
    let age = "47";
    let mut age: u32 = age.trim().parse()
        .expect("Age wasn't assigned a number");
    age = age + 1;
    println!("I'm {} and I want ${}", age, ONE_MIL);

    // ----- DATA TYPES -----
    // Unsigned integer : u8, u16, u32, u64, u128, usize
    // Signed integer : i8, i16, i32, i64, i128, isize
    let max_u32 = u32::MAX;
    println!("Max u32 : {}", max_u32);
    println!("Max u64 : {}", u64::MAX);

    // usize depends on your computer (If 64 bit then it's 64 bit)
    println!("Max usize : {}", usize::MAX);
    println!("Max u128 : {}", u128::MAX);

    // Floating Points : f32, f64
    println!("Max f32 : {}", f32::MAX);
    println!("Max f64 : {}", f64::MAX);

    let _is_true = true; // true or false
    let _my_grade = 'A';

    // ----- MATH -----

    // f32 has 6 digits of precision
    let num_1: f32 = 1.111111111111111;
    println!("f32 : {}", num_1 + 0.111111111111111);

    // f64 has 14 digits of precision
    let num_2: f64 = 1.111111111111111;
    println!("f64 : {}", num_2 + 0.111111111111111);

    // Basic math operators
    let num_3: u32 = 5;
    let num_4: u32 = 4;
    println!("5 + 4 = {}", num_3 + num_4);
    println!("5 - 4 = {}", num_3 - num_4);
    println!("5 * 4 = {}", num_3 * num_4);
    println!("5 / 4 = {}", num_3 / num_4);
    println!("5 % 4 = {}", num_3 % num_4); // Remainder

    // You can use var+= 1 instead of var = var + 1

    // Generate random values between 1 and 100
    let random_num = rand::thread_rng().gen_range(1..101);
    println!("Random : {}", random_num);


    // ----- IF EXPRESSIONS -----
    let age = 8;

    if (age >= 1) && (age <= 18){
        println!("Important Birthday");
    } else if (age == 21) || (age == 50){
        println!("Important Birthday");
    } else if age >= 65 {
        println!("Important Birthday");
    } else {
        println!("Not an Important Birthday");
    }

    // ----- TERNARY OPERATOR -----
    let mut my_age = 47;
    let can_vote = if my_age >= 18 {
        true
    } else {
        false
    };
    println!("Can Vote : {}", can_vote);

    // ----- MATCH -----

    let age2 = 8;
    match age2 {
        1..=18 => println!("Important Birthday"), // 1 through 18
        21 | 50 => println!("Important Birthday"), // 21 or 50
        65..=i32::MAX => println!("Important Birthday"), // > 65
        _ => println!("Not an Important Birthday"), // Default
    };

    // Ordering is enum with values Less, Greater, Equal

    use std::cmp::Ordering;
    let my_age = 18;
    let voting_age = 18;
    match my_age.cmp(&voting_age) {
        Ordering::Less => println!("Can't Vote"),
        Ordering::Greater => println!("Can Vote"),
        Ordering::Equal => println!("You just gained the right to vote!"),
    };

    // ----- ARRAYS -----
    let a = [1,2,3,4];          // elements of same type
    println!("1st : {}", a[0]); // index starts with 0
    println!("Length : {}", a.len());

    // ----- LOOP until break -----
    let arr_2 = [1,2,3,4,5,6,7,8,9];
    let mut loop_idx = 0;
    loop {
        if arr_2[loop_idx] % 2 == 0 {
            loop_idx += 1;
            continue; // Goes to beginning of loop
        }

        if arr_2[loop_idx] == 9 {
            break; // Breaks out of loop
        }

        println!("Val : {}", arr_2[loop_idx]);
        loop_idx += 1;
    }

    // ----- WHILE LOOP -----
    loop_idx = 0;
    while loop_idx < arr_2.len(){
        println!("Arr : {}", arr_2[loop_idx]);
        loop_idx += 1;
    }

    // ----- FOR LOOP -----
    for val in arr_2.iter() {
        println!("Val : {}", val);
    }

    // ----- TUPLES -----
    // fixed length, can be various types
    let my_tuple: (u8, String, f64) = (47, "Derek".to_string(), 50_000.00);
    println!("Name : {}", my_tuple.1);  // get values by index starting at 0
    let (v1, _v2, _v3) = my_tuple;  // assign multiple variables at once
    println!("Age : {}", v1);

    // ----- STRINGS -----
    // There are 2 types of strings
    // 1. String : Vector of bytes that can be changed
    // 2. &str : Points to the string and allows for viewing

    let mut st1 = String::new(); // empty growable string
    st1.push('A');               // Insert a character at the end
    st1.push_str(" word");       // Insert a string at the end
    for word in st1.split_whitespace() { // split by whitespace
        println!("{}", word);
    }

    let st2 = st1.replace("A", "Another"); // Replace by "" for deleting
    println!("{}", st2);

    let st3 = String::from("x r t b h k k a m c");  // Create string of characters
    let mut v1: Vec<char> = st3.chars().collect();  // Convert to a vector
    v1.sort();     // Sort characters inplace
    v1.dedup();    // Remove duplicates
    for char in v1 {
        println!("{}", char);
    }

    let st4: &str = "Random string";        // Create a string literal
    let mut st5: String = st4.to_string();  // Convert to heap allocated String
    println!("{}", st5);

    // Convert string into an array of bytes
    let _byte_arr1 = st5.as_bytes();

    // Get a slice of a string from index 0 to 5
    let st6 = &st5[0..6];
    println!("{}", st6);

    // Get length of string
    println!("String Length : {}", st6.len());

    // Delete values in a string if mutable
    st5.clear();

    // Combine strings
    let st6 = String::from("Just some");
    let st7 = String::from("words");

    // st6 can no longer be used
    // You can only add a reference to a string to another
    let st8 = st6 + &st7;

    // Cycle through letters in a string and print unicode
    for char in st8.bytes() {
        println!("{}", char);
    }

    // Cycle through letters in a string and print characters
    for char in st8.chars() {
        println!("{}", char);
    }
